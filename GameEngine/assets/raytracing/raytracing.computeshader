#version 430

layout (local_size_x = 32, local_size_y = 32) in;

layout (rgba32f, binding = 0) uniform image2D img_output;
// layout (rgba32f, binding = 1) uniform image2D img_input;

layout(std430, binding = 5) buffer layoutName
{
    float time;
    float delta_time;
	float temp;
};

struct ray
{
    vec3 origin;
    vec3 direction;
	
	vec3 at(float t){return origin + t * direction;}
};

bool hit_sphere(vec3 _center, float _radius, ray _r)
{
	vec3 _oc = _r.origin - _center;
	float _a = dot(_r.direction, _r.direction);
	float _b = 2.0 * dot(_oc, _r.direction);
	float _c = dot(_oc, _oc) - _radius * _radius;
	float _discriminant = _b*_b - 4*_a*_c;
	return (_discriminant > 0);
}

vec3 ray_color(ray _r)
{
	if(hit_sphere(vec3(0,0,-1), 0.5, _r))
	{ return vec3(1,0,0); }
	vec3 _unitDirection = _r.direction/length(_r.direction);
	float _t = 0.5*(_unitDirection.y + 1.0);
	return (1.0-_t)*vec3(1.0,1.0,1.0) + _t*vec3(0.5,0.7,1.0);
}

void main() {
  // image
  float aspect_ratio = 16.0/9.0;
  int image_width = 400;
  int image_height = int(image_width/aspect_ratio);
  
  // camera
  float viewport_height = 2.0;
  float viewport_width = aspect_ratio * viewport_height;
  float focal_length = 1.0;
  
  vec3 origin = vec3(0,0,0);
  vec3 horizontal = vec3(viewport_width, 0,0);
  vec3 vertical = vec3(0,viewport_height,0);
  vec3 lower_left_corner = origin - horizontal/2 - vertical/2 - vec3(0,0,focal_length);
  
  // render
  ivec2 dims = imageSize(img_output);
  //uvec3 current_pixel = gl_LocalInvocationID * gl_WorkGroupID;
  uvec3 current_pixel = gl_GlobalInvocationID.xyz;
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  float u = current_pixel.x / (dims.x * 1.0f);
  float v = current_pixel.y / (dims.y *1.0f);
  
  ray r;
  r.origin = origin;
  r.direction = lower_left_corner + u*horizontal + v*vertical - origin;
  vec3 color = ray_color(r);
  vec4 pixel = vec4(color.x, color.y, color.z, 1.0);
  
  imageStore(img_output, pixel_coords, pixel);
}