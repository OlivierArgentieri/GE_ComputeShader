#version 430

layout (local_size_x = 32, local_size_y = 32) in;

layout (rgba32f, binding = 0) uniform image2D img_output;
// layout (rgba32f, binding = 1) uniform image2D img_input;

// ====== SSBO ====== //
layout(std430, binding = 5) buffer layoutName
{
	vec4 center;
	float radius;
    float time;
    float delta_time;
	float temp;
};

struct ray
{
    vec3 origin;
    vec3 direction;
	
	vec3 at(float t){return origin + t * direction;}
};

float length_squared(vec3 _inVec)
{
	return _inVec[0]*_inVec[0] + _inVec[1] * _inVec[1] + _inVec[2] * _inVec[2];
}

float hit_sphere(vec3 _center, float _radius, ray _r)
{
	vec3 _oc = _r.origin - _center;
	float _a = length_squared(_r.direction);
	float _halfB = dot(_oc, _r.direction);
	float _c = length_squared(_oc) - _radius * _radius;
	float _discriminant = _halfB*_halfB - _a*_c;
	if(_discriminant < 0) {
		return -1.0;
	}
	return (-_halfB - sqrt(_discriminant))/_a;
}

vec3 ray_color(ray _r, vec3 _position, float _radius)
{
	
	float _t = hit_sphere(_position, _radius, _r);
	if(_t > 0.0)
	{
		vec3 _temp = _r.at(_t)-vec3(0,0,-1);
		vec3 _N =  _temp/ length(_temp); // unit_vector
		return 0.5*vec3(_N.x+1, _N.y+1, _N.z+1);
	}
	vec3 _unitDirection = _r.direction/length(_r.direction);
	_t = 0.5*(_unitDirection.y + 1.0);
	return (1.0-_t)*vec3(1.0,1.0,1.0) + _t*vec3(0.5,0.7,1.0);
}

void main() {
  // image
  float aspect_ratio = 16.0/9.0;
  int image_width = 400;
  int image_height = int(image_width/aspect_ratio);
  
  // camera
  float viewport_height = 2.0;
  float viewport_width = aspect_ratio * viewport_height;
  float focal_length = 1.0;
  
  vec3 origin = vec3(0,0,0);
  vec3 horizontal = vec3(viewport_width, 0,0);
  vec3 vertical = vec3(0,viewport_height,0);
  vec3 lower_left_corner = origin - horizontal/2 - vertical/2 - vec3(0,0,focal_length);
  
  // render
  ivec2 dims = imageSize(img_output);
  //uvec3 current_pixel = gl_LocalInvocationID * gl_WorkGroupID;
  uvec3 current_pixel = gl_GlobalInvocationID.xyz;
  ivec2 pixel_coords = ivec2(gl_GlobalInvocationID.xy);

  float u = current_pixel.x / (dims.x * 1.0f);
  float v = current_pixel.y / (dims.y *1.0f);
  
  ray r;
  r.origin = origin;
  r.direction = lower_left_corner + u*horizontal + v*vertical - origin;
  vec3 color = ray_color(r, center.xyz, radius);
  vec4 pixel = vec4(color.x, color.y, color.z, 1.0);
  
  imageStore(img_output, pixel_coords, pixel);
}